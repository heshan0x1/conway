# 问题简述
处理 int64 * int64 范围的康威生命游戏

# 思路

## 设计方向
数据范围极大
* 在最多数据的情况下，从内存和 cpu 角度来考虑，单进程、单机都难以覆盖全部用例，需要考虑分布式设计
* 在最少数据的情况下，只需要1(或0)个坐标就可以描述整个 world，需要考虑稀疏的数据结构，应对小数据量的 case

## 分布式
### 计算
采用多进程的方式，方便部署在多台机器

考虑到容灾和实时扩缩容，cell 的状态计算进程采用实时落库+本地缓存的设计方式

整个地图的划分采用格子法，方便做分布式计算，每个格子的计算交由某个进程去执行，因为一个格子的边界计算需要邻接的格子状态，每次拉取数据的时候需要拉取一个九宫格，其中对中心格子进行写操作，对邻接格子进行读操作（存储的时候可以拆分单个格子的边和内存数据，减少邻接格子的查询量）

考虑到海量的存储空间，每个格子内部通过偏移量和(u8, u8)的点来表示，最细粒度的格子边长是 2 ** 8，也就是场景中最多存在 (2 ** 64/2 ** 8) ** 2 = 2 ** 112 个格子

这么多的格子的数量管理也是巨大的计算量和存储成本，考虑用多叉树来优化，只存储需要路径的点，类似3D世界的稀疏八叉树

考虑到单个节点的动态调度分发的单点压力，一个非叶子按照 1MB 的空间预留 = 2 ** 20B，一个索引坐标占 8 + 8 = 2 ** 4B，所以最终决定使用 2**16 叉树，也就是 8 层 65536 叉树

## 65536 叉树设计
### 为什么是 8 层
首先总的格子数是 2**112，所以说叶子结点的数量需要大于等于这个数据

((2 ** 8) ** 7) ** 2 刚好等于 2 ** 112
也就是每一层取取 x 的 8 位，同时取 y 的 8 位，取到第七层的时候这一层的节点数刚好是 2 ** 112，满足叶子结点数，算上 root 的一层，正好是 8 层

### 地址格式
非叶子结点的地址由 7B 的 x 坐标和 7B 的 y 坐标组成，一共 14B 的大小
root 结点是层级 1，高层级的地址取 x、y 的高地址，各个层级的地址是：
1: ""
2: X8Y8
3: X8Y8X7Y7
4: X8Y8X7Y7X6Y6
5: X8Y8X7Y7X6Y6X5Y5
6: X8Y8X7Y7X6Y6X5Y5X4Y4
7: X8Y8X7Y7X6Y6X5Y5X4Y4X3Y3
8: X8Y8X7Y7X6Y6X5Y5X4Y4X3Y3X2Y2

第8层是叶子结点，每个叶子结点（最小粒度的格子）中包含 65536 个点，这些点的的索引值是 16B

***进程通信不是本次演示代码的核心点，本演示方案使用单进程*

### 数据
考虑到数据量级，数据库的选择首先需要支持分布式部署

根据实际延迟的需求，考虑选择 redis or mongo 来做为底层数据库

最坏情况下(gridNum 个格子都被填满)考虑到单数据库的性能上限，需要通过分库分表的方式优化

***数据库操作不是本次演示代码的核心点，使用 map 替代*

### 分布式状态管理
* tick 发起: root 等待上一轮 tick 结束后发起新的一轮
* 叶子结点按层级向下同步开始执行
* job结点收到指令后开始拉取数据并计算
* job结点计算完成后逐级向上同步完成的状态

# 待完善
* 负载均衡根据 jobNode 的相邻关系做，增加缓存的复用率

# 运行方法

## 主程序
main.cpp 中的 InputMap 是主程序的输入，可以修改这个 map 更新测试用例

```bash
g++ -std=c++11 -g main.cpp -o conway 
```

## 测试程序
```bash
g++ -std=c++11 -g test.cpp -o conway_test 
```

